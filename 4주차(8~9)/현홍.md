# 8. 자바스크립트 MV* 패턴

아키텍쳐 패턴 
- MVC
- MVP 
- MVVM 

과거에는 애플리케이션 구조화에 사용되어 왔지만, 현재는 JS 환경에도 적용되어 사용중

## 8.1 MVC 패턴
- 비즈니스 데이터(모델)
- UI (뷰)
- 로직, 사용자 입력 (컨트롤러)

## 8.2 자바스크립트의 MVC

### 모델
모델은 애플리케이션의 데이터를 관리 
모델이 변경될 때 관찰자에게 변경사항을 알린다.

모델을 그룹으로 과리하면 그룹 내의 특정 모델이 변경될 때 그룹의 알림을 기바으로 애플리케이션 로직 작성 가능 

모델이 애플리케이션의 상태를 관리한다고 했었는데, 
지금은 SPA에서 state 라는 용어가 화면에 보이는 데에 중요한 용어이다.

### 뷰
모델에 대한 시각적인 표현으로 현재 상태의 특정 부분만 보여준다. 
뷰는 모델을 관찰하고, 모델에 변화가 생기면 알림을 받는다. 이때 뷰는 스스로를 업데이트한다. 

### 템플릿 
템플릿은 뷰를 생성하기 위해 사용된다.
태그 템플릿 리터럴을 사용하면 js 의 템플릿 리터럴 문법과 함께 템플릿을 조작하고 데이터를 채우는 데 사용할 템플릿을 만들 수 있다.


아~ 그냥 선언해서 가져다 쓰는 느낌
```js
const students = [
  {name,age...}
]
```

### 컨트롤러
모델과 뷰 사이 중재자로, 사용자가 뷰를 조작할 때 모델을 업데이트 하는 역할

## 8.3 MVC 의 장점
- 유지보수 단순화
- 모델과 뷰의 분리로 유닛 테스트 작성이 간단


## 8.6 MVP 패턴
P 는 presenter 를 의미한다
프레젠테이션 로직의 개선에 초점을 맞춘 디자인 패턴 

**프리젠터는 뷰에 대한 UI 로직을 담당하는 구성 요소** 
MVC 와 달리 **뷰에서의 이벤트 호출은 프리젠터로 위임**

P 는 모델을 관찰하고 모델이 변경될 때 뷰를 업데이트,
뷰를 업데이트 할 수 있도록 이벤트를 구독하고 상호작용 하는 것이 프리젠터의 역할

일부 프리젠터는 모델에 데이터를 저장하기 위해 서비스 계층과 상호작용도 한다. 
이벤트를 구독하여 뷰를 업데이트할 수 있도록 한다. 

MVC -> MVP 로의 변화는 애플리케이션의 테스트 용이성을 높이고 뷰와 모델 간의 분리를 명확하게 해준다. 


### MVP vs MVC

MVP 는 프레젠테이션 로직을 최대한 재사용해야 하는 엔터프라이즈 수준의 애플리케이션에서 사용 

뷰가 복잡하고 상호작용이 많으면 여러 컨트롤러에 의존해야 하기 때문에 MVC가 맞지 않다. 
이거를 프리젠터로 캡슐화를 할 수 있다. 

MVP는 프리젠터를 UI 의 완전한 모킹으로 사용하여 다른 구성 요소와 독립적으로 단위 테스트를 할 수 있기 때문에 단위 테스트가 더 쉬울 수 있다. 

## 8.7 MVVM 패턴 
Model - View - ViewModel (모델과 뷰 사이의 인터페이스)

MVP의 기반으로 하는 아키텍쳐 패턴, UI 작업과 비스니스로직 동작 부분을 명확하게 구분한다. 
이러한 기법으로 UI 작업과 개발 작업을 거의 동시에 진행할 수 있다. 

- UI 개발자는 뷰모델에 대한 바인딩을 작성하고, 
- 로직 개발자는 모델과 뷰모델을 관리한다.

### 모델 
모델은 도메인 관련 데이터나 정보만 제공, 유효성 검사 

### 뷰 
뷰는 사용자가 상호작용하는 유일한 부분, 뷰모델의 상태를 표현하는 상호작용이 가능한 UI 
뷰는 화면을 출력할 뿐, 사용자의 입력을 받는 것은 아님 

뷰는 상태를 책임질 책임은 없다. 

### 뷰모델
뷰모델은 뷰의 상태를 유지하고, 뷰에서 발생한 동작에 기반해 모델을 업데이트, 뷰에 이벤트를 발생 

모델의 정보를 뷰가 사용할 수 있는 형태로 변환하고 뷰에서 발생한 명령을 모델로 전달

뷰모델은 사실 모델에 가깝지만, 동시에 뷰의 디스플레이 로직 대부분을 처리한다. 


뷰모델은 UI 계층의 뒤에 위치, 뷰가 필요로 하는 데이터를 모델로부터  가져와 제공하고 데이터와 사용자의 동작 모두를 뷰가 참조하는 출처의 역할 

### 장점 
- MVVM 은 UI와 이를 구동하게 해주는 요소를 동시에 개발 가능
- 뷰를 추상화함으로써 뷰 뒤의 비즈니스 로직의 양을 줄요준다.
- 이벤트 중심  코드에 비해 단위테스트가 쉽다
- UI 자동화나 상호작용에 대한 고려 없이 테스트 가능

### 단점
- 과도한 구현이 될 수 있다.
- 명령형 코드에 비해 복잡해질 수 있다.


## MVC vs MVP vs MVVM 

둘 다 MVC에서 파생된 패턴

### MVC
뷰가 아키텍처의 최상단에 위치,아래는 모델,  옆에는 컨트롤러 가 존재 
이 구조에서 뷰는 모델에 직접 접근이 가능
하지만 전체 모델을 뷰에 노출하는 것은 복잡

### MVP
컨트롤러의 역할을 프리젠터로 대체
프리젠터는 뷰와 같은 계층에 존재, 뷰와 모델 양쪽의 이벤트를 수신하고 동작을 조정
뷰와 뷰모델을 바인딩하는 메커니즘이 없어 각 뷰는 상호작용할 수 있는 인터페이스를 구현해야한다.

### MVVM
상태와 로직 정보를 포함할 수 있는 뷰와 관련된 모델 일부를 생성할 수 있다
이를 통해 전체 모델을 뷰에 노출을 막는다. 
뷰모델은 뷰를 참조할 필요가 없다
뷰는 뷰모델의 속성을 바인딩 하여 모델에 포함된 데이터를 뷰에 표현할 수 있다. 

## 리액트 
리액트는 MVC 로 분류되지 않는다. 
리액트는 선언형 프로그래밍이다. 원하는 상태를 기술하고, 리액트는 그 상태를 기반으로 뷰를 렌더링한다.

리액트 는 서버가 브라우저에 뷰를 직접제공하는 것이 아닌, 데이터를 제공하기 때문이다. 

# 9. 비동기 프로그래밍 패턴

자바스크립트에서 동기 코드는 블로킹 방식으로 실행  
- 순서대로 한번에 한 문장씩 실행 
- 동기 함수를 호출하면 호출자에게 결과를 반환하기 전에 함수 내부의 코드가 처음부터 끝까지 실행

비동기 코드는 논블로킹 방식으로 실행 
- Js 엔진은 현재 실행중인 코드가 다른 작업을 기다리는 동안 백그라운드에서 비동기 코드를 실행 가능 
- 일반적으로 코드의 나머지 부분을 차단하지 않고 오래 실행되는 작업을 수행할 때 유용 


## 프로미스 패턴
프로미스는 세가지 상태를 가진다
- 대기
- 완료
- 거부 

프로미스는 콜백보다 체계적이고 가독성이 높게 비동기 처리가 가능하다. 

프로미스는 Promise 생성자를 사용해 만들 수 있고, 이 생성자는 함수를 인수로 받는다. 
이 함수는 resolve 와 reject 인수를 받는다. 
```js
function makeRequest(url){
  return new Promise((resolve,reject)=>{
    fetch(url)
      .then(response=>response.json())
      .then(data = > resolve(data))
      .catch(error => reject(error))
  })
}
```


### 병렬처리 
Promise.all 메서드를 사용하여 여러 프로미스를 동시에 실행할 수 있다.

```js
Promise.all([
  makeRequest("api1"),
  makeRequest("api2"),
]).then([data1,data2])=>{
  console.log(data1,data2)
}
```

### 프로미스 순차진행

```js
Promsie.resolve()
  .then(()=>makeRequest1())
  .then(()=>makeRequest2())
  .then(()=>makeRequest3())
```

### 프로미스 메모이제이션  패턴
캐시를 이용해 프로미스 함수 호출의 결과를 저장할 수 있다. 

```js
const cache = new Map()
function memoFetch(url){
  if (cache.has(url)){
    return cache.get(url)
  }
  return new Promise((resolve,reject)=>{
    fetch(url)
      .then(res=>res.json)
      .then(data=>{
        cache.set(url,data)
        resolve(data)
      })
  })
}

```


### 프로미스 파이프라인 
프로미스와 함수형 프로그래밍 기법을 활용하여 비동기 처리의 파이프라인을생성 
```js
makeRequest("ap1")
  .then(data=> pipeline(data)
    .then(transform1)
    .then(transform2))
  .then(data=>console.log(data))
```

### 프로미스 재시도 
프로미스가 실패할 때 다시 시도 가능
```js
function makeRequestRetry(url){
  let attempts = 0;
  const makeRequest = ()=> new Promise(res,rej)=>{...}

  const retry = error => {
    attempts ++;
    if (attempts>3){throw new Error()}
    return makeRequest();
  }
  return makeRequest().catch(retry)
}
```


### 프로미스 데코레이터 
고차 함수를 사용해 프로미스에 적용할 수 잇는 데코레이터  생성
프로미스 자체에 추가적인 기능 부여 가능
```js
function logger(fn){
  return function (...args){
    return fn(...args).then(result=>{
      return result;
    })
  }
}
```

### 프로미스 경쟁
여러 프로미스들을 동시에 실행하고 가장 먼저 완료되는 프로미스의 결과를 반환
```js
Promise.race([
  makeRequest("api1"),
  makeRequest("api2"),
]).then(data=>{
  console.log(data)
})
```


### async/await 패턴 
```js
const response = await fetch("api1")
const data = await response.json()
```